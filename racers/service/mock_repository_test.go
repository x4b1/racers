// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service_test

import (
	"context"
	"github.com/xabi93/go-clean/racers"
	"github.com/xabi93/go-clean/racers/service"
	"sync"
)

// Ensure, that RacesRepositoryMock does implement service.RacesRepository.
// If this is not the case, regenerate this file with moq.
var _ service.RacesRepository = &RacesRepositoryMock{}

// RacesRepositoryMock is a mock implementation of service.RacesRepository.
//
//     func TestSomethingThatUsesRacesRepository(t *testing.T) {
//
//         // make and configure a mocked service.RacesRepository
//         mockedRacesRepository := &RacesRepositoryMock{
//             ByIDFunc: func(ctx context.Context, id racers.RaceID) (*racers.Race, error) {
// 	               panic("mock out the ByID method")
//             },
//             SaveFunc: func(ctx context.Context, race racers.Race) error {
// 	               panic("mock out the Save method")
//             },
//         }
//
//         // use mockedRacesRepository in code that requires service.RacesRepository
//         // and then make assertions.
//
//     }
type RacesRepositoryMock struct {
	// ByIDFunc mocks the ByID method.
	ByIDFunc func(ctx context.Context, id racers.RaceID) (*racers.Race, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, race racers.Race) error

	// calls tracks calls to the methods.
	calls struct {
		// ByID holds details about calls to the ByID method.
		ByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID racers.RaceID
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Race is the race argument value.
			Race racers.Race
		}
	}
	lockByID sync.RWMutex
	lockSave sync.RWMutex
}

// ByID calls ByIDFunc.
func (mock *RacesRepositoryMock) ByID(ctx context.Context, id racers.RaceID) (*racers.Race, error) {
	if mock.ByIDFunc == nil {
		panic("RacesRepositoryMock.ByIDFunc: method is nil but RacesRepository.ByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  racers.RaceID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockByID.Lock()
	mock.calls.ByID = append(mock.calls.ByID, callInfo)
	mock.lockByID.Unlock()
	return mock.ByIDFunc(ctx, id)
}

// ByIDCalls gets all the calls that were made to ByID.
// Check the length with:
//     len(mockedRacesRepository.ByIDCalls())
func (mock *RacesRepositoryMock) ByIDCalls() []struct {
	Ctx context.Context
	ID  racers.RaceID
} {
	var calls []struct {
		Ctx context.Context
		ID  racers.RaceID
	}
	mock.lockByID.RLock()
	calls = mock.calls.ByID
	mock.lockByID.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *RacesRepositoryMock) Save(ctx context.Context, race racers.Race) error {
	if mock.SaveFunc == nil {
		panic("RacesRepositoryMock.SaveFunc: method is nil but RacesRepository.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Race racers.Race
	}{
		Ctx:  ctx,
		Race: race,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, race)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedRacesRepository.SaveCalls())
func (mock *RacesRepositoryMock) SaveCalls() []struct {
	Ctx  context.Context
	Race racers.Race
} {
	var calls []struct {
		Ctx  context.Context
		Race racers.Race
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that UsersRepositoryMock does implement service.UsersRepository.
// If this is not the case, regenerate this file with moq.
var _ service.UsersRepository = &UsersRepositoryMock{}

// UsersRepositoryMock is a mock implementation of service.UsersRepository.
//
//     func TestSomethingThatUsesUsersRepository(t *testing.T) {
//
//         // make and configure a mocked service.UsersRepository
//         mockedUsersRepository := &UsersRepositoryMock{
//             ByIDFunc: func(ctx context.Context, id racers.UserID) (*racers.User, error) {
// 	               panic("mock out the ByID method")
//             },
//             SaveFunc: func(ctx context.Context, user racers.User) error {
// 	               panic("mock out the Save method")
//             },
//         }
//
//         // use mockedUsersRepository in code that requires service.UsersRepository
//         // and then make assertions.
//
//     }
type UsersRepositoryMock struct {
	// ByIDFunc mocks the ByID method.
	ByIDFunc func(ctx context.Context, id racers.UserID) (*racers.User, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, user racers.User) error

	// calls tracks calls to the methods.
	calls struct {
		// ByID holds details about calls to the ByID method.
		ByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID racers.UserID
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User racers.User
		}
	}
	lockByID sync.RWMutex
	lockSave sync.RWMutex
}

// ByID calls ByIDFunc.
func (mock *UsersRepositoryMock) ByID(ctx context.Context, id racers.UserID) (*racers.User, error) {
	if mock.ByIDFunc == nil {
		panic("UsersRepositoryMock.ByIDFunc: method is nil but UsersRepository.ByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  racers.UserID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockByID.Lock()
	mock.calls.ByID = append(mock.calls.ByID, callInfo)
	mock.lockByID.Unlock()
	return mock.ByIDFunc(ctx, id)
}

// ByIDCalls gets all the calls that were made to ByID.
// Check the length with:
//     len(mockedUsersRepository.ByIDCalls())
func (mock *UsersRepositoryMock) ByIDCalls() []struct {
	Ctx context.Context
	ID  racers.UserID
} {
	var calls []struct {
		Ctx context.Context
		ID  racers.UserID
	}
	mock.lockByID.RLock()
	calls = mock.calls.ByID
	mock.lockByID.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *UsersRepositoryMock) Save(ctx context.Context, user racers.User) error {
	if mock.SaveFunc == nil {
		panic("UsersRepositoryMock.SaveFunc: method is nil but UsersRepository.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User racers.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, user)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedUsersRepository.SaveCalls())
func (mock *UsersRepositoryMock) SaveCalls() []struct {
	Ctx  context.Context
	User racers.User
} {
	var calls []struct {
		Ctx  context.Context
		User racers.User
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// Ensure, that TeamsRepositoryMock does implement service.TeamsRepository.
// If this is not the case, regenerate this file with moq.
var _ service.TeamsRepository = &TeamsRepositoryMock{}

// TeamsRepositoryMock is a mock implementation of service.TeamsRepository.
//
//     func TestSomethingThatUsesTeamsRepository(t *testing.T) {
//
//         // make and configure a mocked service.TeamsRepository
//         mockedTeamsRepository := &TeamsRepositoryMock{
//             ByIDFunc: func(ctx context.Context, id racers.TeamID) (*racers.Team, error) {
// 	               panic("mock out the ByID method")
//             },
//             ByMemberFunc: func(ctx context.Context, memberID racers.UserID) (*racers.Team, error) {
// 	               panic("mock out the ByMember method")
//             },
//             SaveFunc: func(ctx context.Context, team racers.Team) error {
// 	               panic("mock out the Save method")
//             },
//         }
//
//         // use mockedTeamsRepository in code that requires service.TeamsRepository
//         // and then make assertions.
//
//     }
type TeamsRepositoryMock struct {
	// ByIDFunc mocks the ByID method.
	ByIDFunc func(ctx context.Context, id racers.TeamID) (*racers.Team, error)

	// ByMemberFunc mocks the ByMember method.
	ByMemberFunc func(ctx context.Context, memberID racers.UserID) (*racers.Team, error)

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, team racers.Team) error

	// calls tracks calls to the methods.
	calls struct {
		// ByID holds details about calls to the ByID method.
		ByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID racers.TeamID
		}
		// ByMember holds details about calls to the ByMember method.
		ByMember []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// MemberID is the memberID argument value.
			MemberID racers.UserID
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Team is the team argument value.
			Team racers.Team
		}
	}
	lockByID     sync.RWMutex
	lockByMember sync.RWMutex
	lockSave     sync.RWMutex
}

// ByID calls ByIDFunc.
func (mock *TeamsRepositoryMock) ByID(ctx context.Context, id racers.TeamID) (*racers.Team, error) {
	if mock.ByIDFunc == nil {
		panic("TeamsRepositoryMock.ByIDFunc: method is nil but TeamsRepository.ByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  racers.TeamID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockByID.Lock()
	mock.calls.ByID = append(mock.calls.ByID, callInfo)
	mock.lockByID.Unlock()
	return mock.ByIDFunc(ctx, id)
}

// ByIDCalls gets all the calls that were made to ByID.
// Check the length with:
//     len(mockedTeamsRepository.ByIDCalls())
func (mock *TeamsRepositoryMock) ByIDCalls() []struct {
	Ctx context.Context
	ID  racers.TeamID
} {
	var calls []struct {
		Ctx context.Context
		ID  racers.TeamID
	}
	mock.lockByID.RLock()
	calls = mock.calls.ByID
	mock.lockByID.RUnlock()
	return calls
}

// ByMember calls ByMemberFunc.
func (mock *TeamsRepositoryMock) ByMember(ctx context.Context, memberID racers.UserID) (*racers.Team, error) {
	if mock.ByMemberFunc == nil {
		panic("TeamsRepositoryMock.ByMemberFunc: method is nil but TeamsRepository.ByMember was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		MemberID racers.UserID
	}{
		Ctx:      ctx,
		MemberID: memberID,
	}
	mock.lockByMember.Lock()
	mock.calls.ByMember = append(mock.calls.ByMember, callInfo)
	mock.lockByMember.Unlock()
	return mock.ByMemberFunc(ctx, memberID)
}

// ByMemberCalls gets all the calls that were made to ByMember.
// Check the length with:
//     len(mockedTeamsRepository.ByMemberCalls())
func (mock *TeamsRepositoryMock) ByMemberCalls() []struct {
	Ctx      context.Context
	MemberID racers.UserID
} {
	var calls []struct {
		Ctx      context.Context
		MemberID racers.UserID
	}
	mock.lockByMember.RLock()
	calls = mock.calls.ByMember
	mock.lockByMember.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *TeamsRepositoryMock) Save(ctx context.Context, team racers.Team) error {
	if mock.SaveFunc == nil {
		panic("TeamsRepositoryMock.SaveFunc: method is nil but TeamsRepository.Save was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Team racers.Team
	}{
		Ctx:  ctx,
		Team: team,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, team)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//     len(mockedTeamsRepository.SaveCalls())
func (mock *TeamsRepositoryMock) SaveCalls() []struct {
	Ctx  context.Context
	Team racers.Team
} {
	var calls []struct {
		Ctx  context.Context
		Team racers.Team
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}
